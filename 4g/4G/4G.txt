#include <HardwareSerial.h>
#include <SPIFFS.h>
#include "driver/i2s.h"
#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEAdvertising.h>

#define MODEM_RX 33  // ESP32 æ¥æ”¶å¼•è„šï¼ˆæ¥æ¨¡å— TXDï¼‰
#define MODEM_TX 23  // ESP32 å‘é€å¼•è„šï¼ˆæ¥æ¨¡å— RXDï¼‰
#define BAUD_RATE 115200

HardwareSerial modemSerial(1);

// é€šç”¨å‘é€ AT å‘½ä»¤å¹¶æ‰“å°è¿”å›
void sendATCommand(const char* cmd) {
  modemSerial.println(cmd);
  Serial.print("å‘é€: ");
  Serial.println(cmd);
  delay(500);
  while (modemSerial.available()) {
    Serial.write(modemSerial.read());
  }
  Serial.println();
}

// ç­‰å¾…æŒ‡å®šå“åº”å­—ç¬¦ä¸²
void waitForResponse(const char* expected, unsigned long timeout) {
  unsigned long start = millis();
  String resp = "";
  while (millis() - start < timeout) {
    while (modemSerial.available()) {
      char c = modemSerial.read();
      resp += c;
      Serial.print(c);
      if (resp.indexOf(expected) != -1) return;
    }
  }
  Serial.println("[è¶…æ—¶æœªç­‰åˆ°å“åº”]");
}

// æ‰“å°ä¸²å£æ‰€æœ‰è¿”å›
void readAllAvailable(unsigned long timeout) {
  unsigned long start = millis();
  while (millis() - start < timeout) {
    while (modemSerial.available()) {
      Serial.write(modemSerial.read());
    }
  }
}

#define BUTTON_PIN 32

// I2S éº¦å…‹é£ï¼ˆå½•éŸ³ï¼‰
#define I2S_MIC_SD 15
#define I2S_MIC_WS 19
#define I2S_MIC_SCK 21

// I2S æ‰¬å£°å™¨ï¼ˆæ’­æ”¾ï¼‰
#define I2S_SPK_DOUT 14
#define I2S_SPK_BCLK 12
#define I2S_SPK_LRC 13

// æœåŠ¡å™¨ä¿¡æ¯ - 4Gç‰ˆæœ¬ä½¿ç”¨å…¬ç½‘IPå’Œæ–°ç«¯å£
const char* serverIP = "124.223.102.137";  // å…¬ç½‘æœåŠ¡å™¨IPï¼ˆè¯·ä¿®æ”¹ä¸ºå®é™…å…¬ç½‘IPï¼‰
const int sessionPort = 8083;  // input_serviceç«¯å£ï¼ˆå½•éŸ³ä¸Šä¼ ï¼‰
const int apiPort = 8000;  // main_serviceç«¯å£ï¼ˆAPIè°ƒç”¨ï¼‰

bool isRecording = false;
bool isPlaying = false;
volatile bool needInterrupt = false;
bool is4GConnected = false;
bool isPollingActive = false;  // æ ‡è®°æ˜¯å¦æ¿€æ´»è½®è¯¢çŠ¶æ€
unsigned long pollingStartTime = 0;  // è½®è¯¢å¼€å§‹æ—¶é—´
const unsigned long POLLING_TIMEOUT = 10000;  // 10ç§’è¶…æ—¶
const unsigned long POLLING_INTERVAL = 1000;   // 1ç§’è½®è¯¢é—´éš”

// I2S é…ç½®
i2s_config_t i2s_mic_config = {
  .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),
  .sample_rate = 16000,
  .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,
  .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
  .communication_format = I2S_COMM_FORMAT_STAND_I2S,
  .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
  .dma_buf_count = 8,
  .dma_buf_len = 512,
  .use_apll = false,
  .tx_desc_auto_clear = false,
  .fixed_mclk = 0,
  .mclk_multiple = I2S_MCLK_MULTIPLE_256,
  .bits_per_chan = I2S_BITS_PER_CHAN_16BIT,
};

i2s_config_t i2s_spk_config = {
  .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX),
  .sample_rate = 16000,
  .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,
  .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
  .communication_format = I2S_COMM_FORMAT_STAND_I2S,
  .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
  .dma_buf_count = 8,
  .dma_buf_len = 512,
  .use_apll = false,
  .tx_desc_auto_clear = true,
  .fixed_mclk = 0,
  .mclk_multiple = I2S_MCLK_MULTIPLE_256,
  .bits_per_chan = I2S_BITS_PER_CHAN_16BIT,
};

i2s_pin_config_t mic_pins = {
  .mck_io_num = I2S_PIN_NO_CHANGE,
  .bck_io_num = I2S_MIC_SCK,
  .ws_io_num = I2S_MIC_WS,
  .data_out_num = I2S_PIN_NO_CHANGE,
  .data_in_num = I2S_MIC_SD
};

i2s_pin_config_t spk_pins = {
  .mck_io_num = I2S_PIN_NO_CHANGE,
  .bck_io_num = I2S_SPK_BCLK,
  .ws_io_num = I2S_SPK_LRC,
  .data_out_num = I2S_SPK_DOUT,
  .data_in_num = I2S_PIN_NO_CHANGE
};

// BLEç›¸å…³å˜é‡
BLEAdvertising* pAdvertising;
TaskHandle_t bleTaskHandle = NULL;
bool bleEnabled = true;

String getMACAddress() {
  uint64_t chipId = ESP.getEfuseMac();
  uint8_t mac[6];
  mac[0] = 0x02;
  mac[1] = (chipId >> 32) & 0xFF;
  mac[2] = (chipId >> 24) & 0xFF;
  mac[3] = (chipId >> 16) & 0xFF;
  mac[4] = (chipId >> 8) & 0xFF;
  mac[5] = chipId & 0xFF;
  
  char macStr[18] = { 0 };
  sprintf(macStr, "%02X:%02X:%02X:%02X:%02X:%02X", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
  return String(macStr);
}

void setupI2S() {
  // è®¾ç½®éº¦å…‹é£I2S
  esp_err_t result = i2s_driver_install(I2S_NUM_0, &i2s_mic_config, 0, NULL);
  if (result == ESP_OK) {
    Serial.println("âœ… éº¦å…‹é£I2Sé©±åŠ¨å®‰è£…æˆåŠŸ");
  } else {
    Serial.printf("âŒ éº¦å…‹é£I2Sé©±åŠ¨å®‰è£…å¤±è´¥, é”™è¯¯ç : %d\n", result);
  }
  
  result = i2s_set_pin(I2S_NUM_0, &mic_pins);
  if (result == ESP_OK) {
    Serial.println("âœ… éº¦å…‹é£I2Så¼•è„šè®¾ç½®æˆåŠŸ");
  } else {
    Serial.printf("âŒ éº¦å…‹é£I2Så¼•è„šè®¾ç½®å¤±è´¥, é”™è¯¯ç : %d\n", result);
  }
  
  // è®¾ç½®æ‰¬å£°å™¨I2S
  esp_err_t spkResult = i2s_driver_install(I2S_NUM_1, &i2s_spk_config, 0, NULL);
  if (spkResult == ESP_OK) {
    Serial.println("âœ… æ‰¬å£°å™¨I2Sé©±åŠ¨å®‰è£…æˆåŠŸ");
  } else {
    Serial.printf("âŒ æ‰¬å£°å™¨I2Sé©±åŠ¨å®‰è£…å¤±è´¥, é”™è¯¯ç : %d\n", spkResult);
  }
  
  spkResult = i2s_set_pin(I2S_NUM_1, &spk_pins);
  if (spkResult == ESP_OK) {
    Serial.println("âœ… æ‰¬å£°å™¨I2Så¼•è„šè®¾ç½®æˆåŠŸ");
  } else {
    Serial.printf("âŒ æ‰¬å£°å™¨I2Så¼•è„šè®¾ç½®å¤±è´¥, é”™è¯¯ç : %d\n", spkResult);
  }
}

// 4Gæ¨¡å—åˆå§‹åŒ– - å»ºç«‹åˆ°input_serviceå’Œmain_serviceçš„è¿æ¥
bool init4G() {
  Serial.println("ğŸ”§ å¼€å§‹åˆå§‹åŒ–4Gæ¨¡å—...");
  
  // åŸºç¡€4Gæ¨¡å—åˆå§‹åŒ– AT æŒ‡ä»¤åºåˆ—
  sendATCommand("AT"); // æµ‹è¯•æ¨¡å—æ˜¯å¦å“åº”
  sendATCommand("ATE0"); // å…³é—­å‘½ä»¤å›æ˜¾
  sendATCommand("AT+CPIN?"); // æŸ¥è¯¢ SIM å¡çŠ¶æ€
  sendATCommand("AT+CEREG?"); // æŸ¥è¯¢ç½‘ç»œæ³¨å†ŒçŠ¶æ€
  sendATCommand("AT+CSQ"); // æŸ¥è¯¢ä¿¡å·å¼ºåº¦
  sendATCommand("AT+CGSN"); // æŸ¥è¯¢æ¨¡å—åºåˆ—å·ï¼ˆIMEIï¼‰
  sendATCommand("AT+COPS?"); // æŸ¥è¯¢å½“å‰è¿è¥å•†
  sendATCommand("AT+CGPADDR"); // æŸ¥è¯¢PDPæ¿€æ´»çŠ¶æ€åŠåˆ†é…çš„IPåœ°å€
  
  // å»ºç«‹åˆ°input_serviceçš„TCPè¿æ¥ (Socket 0)
  Serial.println("ğŸ”— å»ºç«‹åˆ°input_serviceçš„è¿æ¥...");
  String connectCmd0 = "AT+MIPOPEN=0,\"TCP\",\"" + String(serverIP) + "\"," + String(sessionPort);
  sendATCommand(connectCmd0.c_str());
  waitForResponse("+MIPOPEN: 0,0", 10000); // ç­‰å¾…è¿æ¥æˆåŠŸ
  
  // å»ºç«‹åˆ°main_serviceçš„TCPè¿æ¥ (Socket 1) ç”¨äºAPIè°ƒç”¨
  Serial.println("ğŸ”— å»ºç«‹åˆ°main_serviceçš„è¿æ¥...");
  String connectCmd1 = "AT+MIPOPEN=1,\"TCP\",\"" + String(serverIP) + "\"," + String(apiPort);
  sendATCommand(connectCmd1.c_str());
  waitForResponse("+MIPOPEN: 1,0", 10000); // ç­‰å¾…è¿æ¥æˆåŠŸ
  
  Serial.println("âœ… 4Gæ¨¡å—åˆå§‹åŒ–å®Œæˆ");
  is4GConnected = true;
  return true;
}

// 4Gåè®®ï¼šå‘é€ä¼šè¯å¼€å§‹ä¿¡å·
void sendSessionStart() {
  if (!is4GConnected) return;
  
  String mac = getMACAddress();
  String sessionMsg = "SESSION_START:" + mac;
  
  String sendCmd = "AT+MIPSEND=0," + String(sessionMsg.length());
  modemSerial.println(sendCmd);
  delay(100);
  modemSerial.print(sessionMsg);
  
  Serial.println("ğŸ“¤ å·²å‘é€ä¼šè¯å¼€å§‹ä¿¡å·: " + sessionMsg);
}

// 4Gåè®®ï¼šæµå¼å‘é€éŸ³é¢‘æ•°æ®åˆ°input_service
void sendAudioData(const uint8_t* data, size_t length) {
  if (!is4GConnected) return;
  
  String sendCmd = "AT+MIPSEND=0," + String(length);
  modemSerial.println(sendCmd);
  delay(50);
  
  // å‘é€éŸ³é¢‘æ•°æ®
  modemSerial.write(data, length);
  
  // ç­‰å¾…å‘é€å®Œæˆ
  unsigned long start = millis();
  while (millis() - start < 2000) {
    if (modemSerial.available()) {
      String response = modemSerial.readString();
      if (response.indexOf("+MIPSEND: 0") != -1) {
        return;
      }
    }
  }
}

// 4Gåè®®ï¼šå‘é€å½•éŸ³å®Œæˆä¿¡å·
void sendRecordingComplete() {
  if (!is4GConnected) return;
  
  String completeMsg = "RECORDING_COMPLETE";
  String sendCmd = "AT+MIPSEND=0," + String(completeMsg.length());
  modemSerial.println(sendCmd);
  delay(100);
  modemSerial.print(completeMsg);
  
  Serial.println("ğŸ“¤ å·²å‘é€å½•éŸ³å®Œæˆä¿¡å·");
}

// æ¿€æ´»è½®è¯¢æœºåˆ¶
void activatePolling() {
  isPollingActive = true;
  pollingStartTime = millis();
  Serial.println("ğŸ”„ æ¿€æ´»éŸ³é¢‘è½®è¯¢æœºåˆ¶");
}

// åœæ­¢è½®è¯¢æœºåˆ¶
void stopPolling() {
  isPollingActive = false;
  pollingStartTime = 0;
  Serial.println("â¹ï¸ åœæ­¢éŸ³é¢‘è½®è¯¢æœºåˆ¶");
}

// æ£€æŸ¥è½®è¯¢è¶…æ—¶
bool isPollingTimeout() {
  if (!isPollingActive) return false;
  return (millis() - pollingStartTime) > POLLING_TIMEOUT;
}

// 4Gåè®®ï¼šHTTP APIè°ƒç”¨è¯·æ±‚éŸ³é¢‘ (æ”¹è¿›ç‰ˆ)
void requestAudioFromAPI() {
  if (!is4GConnected || !isPollingActive) return;
  
  // æ£€æŸ¥è½®è¯¢è¶…æ—¶
  if (isPollingTimeout()) {
    Serial.println("â° è½®è¯¢è¶…æ—¶10ç§’ï¼Œè‡ªåŠ¨åœæ­¢è½®è¯¢");
    stopPolling();
    return;
  }
  
  String mac = getMACAddress();
  
  // æ„å»ºHTTP POSTè¯·æ±‚åˆ°main_serviceçš„4G API
  String httpRequest = "POST /api/4g/request_audio?mac=" + mac + " HTTP/1.1\r\n";
  httpRequest += "Host: " + String(serverIP) + ":" + String(apiPort) + "\r\n";
  httpRequest += "Content-Length: 0\r\n";
  httpRequest += "Connection: keep-alive\r\n\r\n";
  
  String sendCmd = "AT+MIPSEND=1," + String(httpRequest.length());
  modemSerial.println(sendCmd);
  delay(100);
  modemSerial.print(httpRequest);
  
  // è¯»å–HTTPå“åº”
  delay(1000);
  String httpResponse = "";
  unsigned long start = millis();
  while (millis() - start < 3000) {
    if (modemSerial.available()) {
      httpResponse += modemSerial.readString();
    }
  }
  
  // è§£æJSONå“åº”
  if (httpResponse.indexOf("\"status\":\"audio_data\"") != -1) {
    // æ‰¾åˆ°éŸ³é¢‘æ•°æ®
    int audioStart = httpResponse.indexOf("\"audio\":\"") + 9;
    int audioEnd = httpResponse.indexOf("\"", audioStart);
    if (audioStart > 8 && audioEnd > audioStart) {
      String audioBase64 = httpResponse.substring(audioStart, audioEnd);
      
      Serial.println("ğŸ”Š æ”¶åˆ°éŸ³é¢‘æ•°æ®ï¼Œå¼€å§‹æ’­æ”¾...");
      isPlaying = true;
      
      // è§£ç å¹¶æ’­æ”¾éŸ³é¢‘
      playAudioBase64(audioBase64);
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯æœ€åä¸€æ®µéŸ³é¢‘
      if (httpResponse.indexOf("\"final\":true") != -1) {
        Serial.println("âœ… æ”¶åˆ°å®Œæˆæ ‡è®°ï¼Œæ‰€æœ‰éŸ³é¢‘æ’­æ”¾å®Œæˆ");
        stopPolling(); // æ”¶åˆ°å®Œæˆæ ‡è®°ï¼Œåœæ­¢è½®è¯¢
        isPlaying = false;
      } else {
        Serial.println("â¡ï¸ è¿˜æœ‰æ›´å¤šéŸ³é¢‘ï¼Œç»§ç»­è½®è¯¢...");
      }
    }
  } else if (httpResponse.indexOf("\"status\":\"no_audio\"") != -1) {
    // æš‚æ— éŸ³é¢‘ï¼Œç»§ç»­ç­‰å¾…
    Serial.println("â³ æœåŠ¡å™¨éŸ³é¢‘å¤„ç†ä¸­...");
  }
}

// Base64è§£ç è¡¨
const char base64_chars[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

// Base64è§£ç å‡½æ•°
int base64_decode(const String& encoded, uint8_t* output, int maxLen) {
  int len = encoded.length();
  int i = 0, j = 0;
  uint8_t char_array_4[4], char_array_3[3];
  
  while (i < len && encoded[i] != '=') {
    if (j == 4) {
      for (int k = 0; k < 4; k++) {
        char pos = strchr(base64_chars, char_array_4[k]) - base64_chars;
        char_array_4[k] = pos;
      }
      
      char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
      char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
      char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];
      
      if (j - 3 + 3 > maxLen) break;
      memcpy(output + j - 3, char_array_3, 3);
      j = 0;
    }
    
    char_array_4[j++] = encoded[i++];
  }
  
  if (j) {
    for (int k = j; k < 4; k++) char_array_4[k] = 0;
    for (int k = 0; k < 4; k++) {
      char pos = strchr(base64_chars, char_array_4[k]) - base64_chars;
      char_array_4[k] = pos;
    }
    
    char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
    char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
    char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];
    
    for (int k = 0; k < j - 1; k++) {
      if (j + k > maxLen) break;
      output[j + k] = char_array_3[k];
    }
  }
  
  return j;
}

// å®Œæ•´çš„Base64éŸ³é¢‘æ’­æ”¾å®ç°
void playAudioBase64(String audioBase64) {
  Serial.println("ğŸµ å¼€å§‹è§£ç å¹¶æ’­æ”¾éŸ³é¢‘ç‰‡æ®µï¼ŒBase64é•¿åº¦: " + String(audioBase64.length()));
  
  // è®¡ç®—è§£ç åçš„æ•°æ®å¤§å°ï¼ˆå¤§æ¦‚æ˜¯åŸé•¿åº¦çš„3/4ï¼‰
  int decodedSize = (audioBase64.length() * 3) / 4;
  uint8_t* audioData = (uint8_t*)malloc(decodedSize);
  
  if (!audioData) {
    Serial.println("âŒ å†…å­˜åˆ†é…å¤±è´¥");
    return;
  }
  
  // Base64è§£ç 
  int actualSize = base64_decode(audioBase64, audioData, decodedSize);
  Serial.printf("âœ… Base64è§£ç å®Œæˆï¼Œå®é™…å¤§å°: %d bytes\n", actualSize);
  
  // é€šè¿‡I2Sæ’­æ”¾éŸ³é¢‘
  const int chunkSize = 512;
  int bytesPlayed = 0;
  
  while (bytesPlayed < actualSize && !needInterrupt) {
    int remainingBytes = actualSize - bytesPlayed;
    int currentChunkSize = (remainingBytes > chunkSize) ? chunkSize : remainingBytes;
    
    size_t bytesWritten;
    esp_err_t result = i2s_write(I2S_NUM_1, audioData + bytesPlayed, currentChunkSize, &bytesWritten, portMAX_DELAY);
    
    if (result == ESP_OK) {
      bytesPlayed += bytesWritten;
    } else {
      Serial.printf("âŒ I2Så†™å…¥å¤±è´¥, é”™è¯¯ç : %d\n", result);
      break;
    }
    
    // æ£€æŸ¥ä¸­æ–­æ ‡å¿—
    if (needInterrupt) {
      Serial.println("âš ï¸ éŸ³é¢‘æ’­æ”¾è¢«ä¸­æ–­");
      break;
    }
    
    delay(1); // ç¨å¾®å»¶è¿Ÿé¿å…çœ‹é—¨ç‹—é‡ç½®
  }
  
  free(audioData);
  Serial.println("âœ… éŸ³é¢‘ç‰‡æ®µæ’­æ”¾å®Œæˆ");
}

// 4Gåè®®ï¼šå‘é€ä¸­æ–­ä¿¡å·
void sendInterruptSignal() {
  if (!is4GConnected) return;
  
  String mac = getMACAddress();
  
  // é€šè¿‡HTTP APIå‘é€ä¸­æ–­è¯·æ±‚
  String httpRequest = "POST /api/4g/interrupt?mac=" + mac + " HTTP/1.1\r\n";
  httpRequest += "Host: " + String(serverIP) + ":" + String(apiPort) + "\r\n";
  httpRequest += "Content-Length: 0\r\n";
  httpRequest += "Connection: keep-alive\r\n\r\n";
  
  String sendCmd = "AT+MIPSEND=1," + String(httpRequest.length());
  modemSerial.println(sendCmd);
  delay(100);
  modemSerial.print(httpRequest);
  
  Serial.println("ğŸ“¤ å·²å‘é€ä¸­æ–­ä¿¡å·åˆ°æœåŠ¡å™¨");
}

void setupBLE() {
  if (!bleEnabled) {
    Serial.println("â„¹ï¸ BLEåŠŸèƒ½å·²ç¦ç”¨");
    return;
  }
  
  Serial.println("ğŸ”§ åˆå§‹åŒ–BLE...");
  
  String deviceName = "ESP32_Audio_" + getMACAddress().substring(12);
  deviceName.replace(":", "");
  
  BLEDevice::init(deviceName.c_str());
  Serial.printf("âœ… BLEè®¾å¤‡åˆå§‹åŒ–å®Œæˆï¼Œè®¾å¤‡å: %s\n", deviceName.c_str());
  
  xTaskCreatePinnedToCore(
    bleTask,
    "BLETask",
    4000,
    NULL,
    1,
    &bleTaskHandle,
    1
  );
  
  Serial.println("ğŸš€ BLEä»»åŠ¡å·²åœ¨æ ¸å¿ƒ1å¯åŠ¨");
}

void bleTask(void* parameter) {
  Serial.println("ğŸ“¶ BLEä»»åŠ¡å¯åŠ¨åœ¨æ ¸å¿ƒ1");
  
  uint8_t beaconData[25] = {
    0x4C, 0x00,
    0x02, 0x15,
    0x12, 0x34, 0x56, 0x78,
    0x12, 0x34,
    0x12, 0x34,
    0x12, 0x34,
    0x12, 0x34, 0x56, 0x78, 0x90, 0xAB,
    0x03, 0xE9,
    0x00, 0x2A,
    0xC5
  };

  BLEAdvertisementData advData;
  advData.setFlags(0x04);
  advData.setManufacturerData(String((char*)beaconData, 25)); 
  
  pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->setScanResponse(false);
  pAdvertising->setAdvertisementType(ADV_TYPE_NONCONN_IND);
  pAdvertising->setMinInterval(1600);
  pAdvertising->setMaxInterval(1600);
  pAdvertising->setAdvertisementData(advData);
  pAdvertising->start();
  
  Serial.println("âœ… BLE iBeaconå¹¿æ’­å·²å¯åŠ¨");
  
  while (bleEnabled) {
    vTaskDelay(1000 / portTICK_PERIOD_MS);
  }
  
  if (pAdvertising) {
    pAdvertising->stop();
    Serial.println("ğŸ›‘ BLEå¹¿æ’­å·²åœæ­¢");
  }
  
  bleTaskHandle = NULL;
  Serial.println("ğŸ“´ BLEä»»åŠ¡å·²ç»“æŸ");
  vTaskDelete(NULL);
}

void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("\n====== ESP32è¯­éŸ³åŠ©æ‰‹(4Gç‰ˆ)å¯åŠ¨ä¸­ ======");
  
  // 1. åˆå§‹åŒ–4Gæ¨¡å—
  modemSerial.begin(BAUD_RATE, SERIAL_8N1, MODEM_RX, MODEM_TX);
  delay(3000);
  
  if (!init4G()) {
    Serial.println("âŒ 4Gè¿æ¥å¤±è´¥ï¼Œç³»ç»Ÿæ— æ³•å¯åŠ¨");
    while(1);
  }

  // 2. åˆå§‹åŒ–æ–‡ä»¶ç³»ç»Ÿ
  if(SPIFFS.begin(true)) {
    Serial.println("âœ… SPIFFSåˆå§‹åŒ–æˆåŠŸ");
  } else {
    Serial.println("âŒ SPIFFSåˆå§‹åŒ–å¤±è´¥");
  }
  
  // 3. åˆå§‹åŒ–I2S
  setupI2S();
  
  // 4. åˆå§‹åŒ–BLE
  setupBLE();
  
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  Serial.println("âœ… æŒ‰é’®åˆå§‹åŒ–å®Œæˆ");
  
  Serial.println("\nğŸš€ ESP32è¯­éŸ³åŠ©æ‰‹(4Gç‰ˆ)å·²å¯åŠ¨");
  Serial.println("- æŒ‰ä¸‹æŒ‰é’®å¼€å§‹å½•éŸ³ï¼ˆæµå¼ä¼ è¾“ï¼‰");
  Serial.println("- æ¾å¼€æŒ‰é’®ç»“æŸå½•éŸ³å¹¶ç­‰å¾…éŸ³é¢‘");
  Serial.println("- æŒ‰ä¸‹æŒ‰é’®å¯ä¸­æ–­æ’­æ”¾å¹¶æ¸…é™¤æœåŠ¡ç«¯é˜Ÿåˆ—");
  Serial.println("- BLE iBeaconå¹¿æ’­å·²å¯ç”¨");
  Serial.println("- ä¿æŒåŸæœ‰æµå¼ä¼ è¾“ï¼Œä¼˜åŒ–è¯·æ±‚æœºåˆ¶");
  Serial.println("====================================");
}

void loop() {
  // æŒ‰é’®å¤„ç†é€»è¾‘
  static bool lastButtonState = HIGH;
  bool currentButtonState = digitalRead(BUTTON_PIN);
  
  if (currentButtonState != lastButtonState) {
    delay(50); // é˜²æŠ–åŠ¨
    if (digitalRead(BUTTON_PIN) == currentButtonState) {
      if (currentButtonState == LOW) {
        Serial.println("\nğŸ”˜ æŒ‰é’®æŒ‰ä¸‹");
        if (isPlaying || isPollingActive) {
          // ä¸­æ–­æ’­æ”¾å’Œè½®è¯¢
          Serial.println("âš ï¸ å¼ºåˆ¶åœæ­¢æ’­æ”¾å’Œè½®è¯¢...");
          sendInterruptSignal(); // å‘é€ä¸­æ–­ä¿¡å·åˆ°æœåŠ¡å™¨
          stopPolling(); // åœæ­¢è½®è¯¢
          isPlaying = false;
          needInterrupt = true; // è®¾ç½®ä¸­æ–­æ ‡å¿—
          Serial.println("âœ… æ’­æ”¾å·²åœæ­¢ï¼Œç­‰å¾…æ–°å½•éŸ³");
        } else {
          // å¼€å§‹å½•éŸ³ - 4Gåè®®æµç¨‹
          sendSessionStart(); // å‘é€ä¼šè¯å¼€å§‹ä¿¡å·
          isRecording = true;
          needInterrupt = false; // æ¸…é™¤ä¸­æ–­æ ‡å¿—
          Serial.println("ğŸ¤ å¼€å§‹å½•éŸ³ï¼ˆ4Gæµå¼ä¼ è¾“ï¼‰...");
        }
      } else {
        Serial.println("\nğŸ”˜ æŒ‰é’®é‡Šæ”¾");
        if (isRecording) {
          // åœæ­¢å½•éŸ³å¹¶æ¿€æ´»è½®è¯¢ - 4Gåè®®æµç¨‹
          sendRecordingComplete(); // å‘é€å½•éŸ³å®Œæˆä¿¡å·
          isRecording = false;
          activatePolling(); // æ¿€æ´»è½®è¯¢æœºåˆ¶
          Serial.println("ğŸ›‘ åœæ­¢å½•éŸ³ï¼Œæ¿€æ´»éŸ³é¢‘è½®è¯¢...");
        }
      }
    }
    lastButtonState = currentButtonState;
  }
  
  // 4Gåè®®ï¼šæµå¼å½•éŸ³æ•°æ®å¤„ç†
  if (isRecording && is4GConnected) {
    uint8_t buffer[512];
    size_t bytesRead;
    esp_err_t readResult = i2s_read(I2S_NUM_0, buffer, sizeof(buffer), &bytesRead, 0);
    if (readResult == ESP_OK && bytesRead > 0) {
      sendAudioData(buffer, bytesRead); // æµå¼å‘é€åˆ°input_service
    }
  }
  
  // 4Gåè®®ï¼šæ¿€æ´»è½®è¯¢éŸ³é¢‘è¯·æ±‚é€»è¾‘
  static unsigned long lastRequestTime = 0;
  if (isPollingActive && !isRecording && 
      millis() - lastRequestTime > POLLING_INTERVAL) { // æŒ‰è½®è¯¢é—´éš”è¯·æ±‚
    requestAudioFromAPI(); // ä½¿ç”¨HTTP APIè¯·æ±‚éŸ³é¢‘
    lastRequestTime = millis();
  }
  
  delay(10); // ç¨å¾®å¢åŠ å»¶è¿Ÿï¼Œå‡å°‘CPUå ç”¨
}
